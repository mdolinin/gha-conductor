/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * moduleName must be unique across the whole mono repo
 */
export type TheModuleNameSchema = string;
/**
 * teamNamespace must be unique across the whole mono repo
 */
export type TheTeamNamespaceSchema = string;
export type PropertiesDefaultFileChangeTriggerItems = TheFirstAnyOfSchema;
/**
 * List of files that are tracked under defaultFileChangeTrigger variable to trigger pipeline based on the event.
 */
export type TheFirstAnyOfSchema = string;
/**
 * List of files that are tracked under defaultFileChangeTrigger variable to trigger pipeline based on the event.
 */
export type TheDefaultFileChangeTriggerSchema = PropertiesDefaultFileChangeTriggerItems[];
export type PropertiesOnPullRequestItems = OnPullRequestHookSchema;
/**
 * name of the hook, must be unique in the .gha.yaml file
 */
export type HookNameSchema = string;
/**
 * GHA workflow name to run, w/o file extension
 */
export type GHAWorkflowNameSchema = string;
/**
 * branch name for GHA workflow if different from default
 */
export type TheRefSchema = string;
export type PropertiesOnPullRequestItemsAnyOf0PropertiesTriggerConditionsPropertiesFileChangesMatchAnyItems =
  FileChangeMatcherSchema;
/**
 * Glob to match files in the PR
 */
export type FileChangeMatcherSchema = string;
/**
 * List of globs that will trigger the GHA workflow, if files change in the PR match any of these globs
 */
export type TheFileChangesMatchAnySchema =
  PropertiesOnPullRequestItemsAnyOf0PropertiesTriggerConditionsPropertiesFileChangesMatchAnyItems[];
/**
 * Workflows to run on Github pull request open, reopened, synchronize events
 */
export type TheOnPullRequestSchema = PropertiesOnPullRequestItems[];
export type PropertiesOnBranchMergeItems = OnBranchMergeHookSchema;
/**
 * name of the hook, must be unique in the .gha.yaml file
 */
export type HookNameSchema1 = string;
/**
 * GHA workflow name to run, w/o file extension
 */
export type GHAWorkflowNameSchema1 = string;
/**
 * branch name for GHA workflow if different from default
 */
export type TheRefSchema1 = string;
export type PropertiesOnBranchMergeItemsAnyOf0PropertiesTriggerConditionsPropertiesDestinationBranchMatchesAnyItems =
  TargetBranchNameSchema;
/**
 * Name of the target branch where the changes are merged.
 */
export type TargetBranchNameSchema = string;
/**
 * List of the target branches where the changes are merged.
 */
export type TheDestinationBranchMatchesAnySchema =
  PropertiesOnBranchMergeItemsAnyOf0PropertiesTriggerConditionsPropertiesDestinationBranchMatchesAnyItems[];
export type PropertiesOnBranchMergeItemsAnyOf0PropertiesTriggerConditionsPropertiesFileChangesMatchAnyItems =
  FileChangeMatcherSchema1;
/**
 * Glob to match files in the PR
 */
export type FileChangeMatcherSchema1 = string;
/**
 * List of globs that will trigger the GHA workflow, if files change in the PR match any of these globs
 */
export type TheFileChangesMatchAnySchema1 =
  PropertiesOnBranchMergeItemsAnyOf0PropertiesTriggerConditionsPropertiesFileChangesMatchAnyItems[];
/**
 * Workflow to run on Github branch merge event
 */
export type TheOnBranchMergeSchema = PropertiesOnBranchMergeItems[];
export type PropertiesOnPullRequestCloseItems = OnPullRequestCloseHookSchema;
/**
 * name of the hook, must be unique in the .gha.yaml file
 */
export type HookNameSchema2 = string;
/**
 * GHA workflow name to run, w/o file extension
 */
export type GHAWorkflowNameSchema2 = string;
/**
 * branch name for GHA workflow if different from default
 */
export type TheRefSchema2 = string;
export type PropertiesOnPullRequestCloseItemsAnyOf0PropertiesTriggerConditionsPropertiesFileChangesMatchAnyItems =
  FileChangeMatcherSchema2;
/**
 * Glob to match files in the PR
 */
export type FileChangeMatcherSchema2 = string;
/**
 * List of globs that will trigger the GHA workflow, if files change in the PR match any of these globs
 */
export type TheFileChangesMatchAnySchema2 =
  PropertiesOnPullRequestCloseItemsAnyOf0PropertiesTriggerConditionsPropertiesFileChangesMatchAnyItems[];
/**
 * Workflows to run on Github pull request close event, but not merged.
 */
export type TheOnPullRequestCloseSchema = PropertiesOnPullRequestCloseItems[];
export type PropertiesOnSlashCommandItems = OnSlashCommandHookSchema;
/**
 * name of the hook, must be unique in the .gha.yaml file
 */
export type HookNameSchema3 = string;
/**
 * GHA workflow name to run, w/o file extension
 */
export type GHAWorkflowNameSchema3 = string;
/**
 * branch name for GHA workflow if different from default
 */
export type TheRefSchema3 = string;
export type PropertiesOnSlashCommandItemsAnyOf0PropertiesTriggerConditionsPropertiesSlashCommandsItems =
  SlashCommandMatcherSchema;
/**
 * Slash command to match in the PR comment
 */
export type SlashCommandMatcherSchema = string;
/**
 * List of slash commands that will trigger the GHA workflow, if the PR comment matches any of these commands.
 */
export type TheSlashCommandsSchema =
  PropertiesOnSlashCommandItemsAnyOf0PropertiesTriggerConditionsPropertiesSlashCommandsItems[];
/**
 * Workflows to run on Github slash command comments
 */
export type TheOnSlashCommandSchema = PropertiesOnSlashCommandItems[];

/**
 * The root schema comprises the entire JSON document.
 */
export interface TheRootSchema {
  moduleName: TheModuleNameSchema;
  teamNamespace: TheTeamNamespaceSchema;
  sharedParams: TheSharedParamsSchema;
  defaultFileChangeTrigger: TheDefaultFileChangeTriggerSchema;
  onPullRequest: TheOnPullRequestSchema;
  onBranchMerge: TheOnBranchMergeSchema;
  onPullRequestClose?: TheOnPullRequestCloseSchema;
  onSlashCommand?: TheOnSlashCommandSchema;
  [k: string]: unknown;
}
/**
 * Params shared across all hooks in the .gha.yaml file.
 */
export interface TheSharedParamsSchema {
  [k: string]: unknown;
}
/**
 * Workflow to run on Github pull request open, reopened, synchronize events
 */
export interface OnPullRequestHookSchema {
  name: HookNameSchema;
  pipelineRef: ThePipelineRefSchema;
  pipelineRunValues: ThePipelineRunValuesSchema;
  triggerConditions: TheTriggerConditionsSchema;
  [k: string]: unknown;
}
/**
 * Reference to the GHA workflow to run
 */
export interface ThePipelineRefSchema {
  name: GHAWorkflowNameSchema;
  ref?: TheRefSchema;
  [k: string]: unknown;
}
/**
 * Values to pass to the GHA workflow
 */
export interface ThePipelineRunValuesSchema {
  params: TheParamsSchema;
  [k: string]: unknown;
}
/**
 * Parameters to pass to the GHA workflow
 */
export interface TheParamsSchema {
  [k: string]: unknown;
}
/**
 * Conditions to trigger the GHA workflow
 */
export interface TheTriggerConditionsSchema {
  fileChangesMatchAny: TheFileChangesMatchAnySchema;
  [k: string]: unknown;
}
/**
 * Workflow to run on Github branch merge event
 */
export interface OnBranchMergeHookSchema {
  name: HookNameSchema1;
  pipelineRef: ThePipelineRefSchema1;
  pipelineRunValues: ThePipelineRunValuesSchema1;
  triggerConditions: TheTriggerConditionsSchema1;
  [k: string]: unknown;
}
/**
 * Reference to the GHA workflow to run
 */
export interface ThePipelineRefSchema1 {
  name: GHAWorkflowNameSchema1;
  ref?: TheRefSchema1;
  [k: string]: unknown;
}
/**
 * Values to pass to the GHA workflow
 */
export interface ThePipelineRunValuesSchema1 {
  params: TheParamsSchema1;
  [k: string]: unknown;
}
/**
 * Parameters to pass to the GHA workflow
 */
export interface TheParamsSchema1 {
  [k: string]: unknown;
}
/**
 * Conditions to trigger the GHA workflow
 */
export interface TheTriggerConditionsSchema1 {
  destinationBranchMatchesAny: TheDestinationBranchMatchesAnySchema;
  fileChangesMatchAny: TheFileChangesMatchAnySchema1;
  [k: string]: unknown;
}
/**
 * Workflow to run on Github pull request close event, but not merged.
 */
export interface OnPullRequestCloseHookSchema {
  name: HookNameSchema2;
  pipelineRef: ThePipelineRefSchema2;
  pipelineRunValues: ThePipelineRunValuesSchema2;
  triggerConditions: TheTriggerConditionsSchema2;
  [k: string]: unknown;
}
/**
 * Reference to the GHA workflow to run
 */
export interface ThePipelineRefSchema2 {
  name: GHAWorkflowNameSchema2;
  ref?: TheRefSchema2;
  [k: string]: unknown;
}
/**
 * Values to pass to the GHA workflow
 */
export interface ThePipelineRunValuesSchema2 {
  params: TheParamsSchema2;
  [k: string]: unknown;
}
/**
 * Parameters to pass to the GHA workflow
 */
export interface TheParamsSchema2 {
  [k: string]: unknown;
}
/**
 * Conditions to trigger the GHA workflow
 */
export interface TheTriggerConditionsSchema2 {
  fileChangesMatchAny: TheFileChangesMatchAnySchema2;
  [k: string]: unknown;
}
/**
 * Workflow to run when a slash command is issued on a PR
 */
export interface OnSlashCommandHookSchema {
  name: HookNameSchema3;
  pipelineRef: ThePipelineRefSchema3;
  pipelineRunValues: ThePipelineRunValuesSchema3;
  triggerConditions: TheTriggerConditionsSchema3;
  [k: string]: unknown;
}
/**
 * Reference to the GHA workflow to run
 */
export interface ThePipelineRefSchema3 {
  name: GHAWorkflowNameSchema3;
  ref?: TheRefSchema3;
  [k: string]: unknown;
}
/**
 * Values to pass to the GHA workflow
 */
export interface ThePipelineRunValuesSchema3 {
  params: TheParamsSchema3;
  [k: string]: unknown;
}
/**
 * Parameters to pass to the GHA workflow
 */
export interface TheParamsSchema3 {
  [k: string]: unknown;
}
/**
 * Conditions to trigger the GHA workflow
 */
export interface TheTriggerConditionsSchema3 {
  slashCommands: TheSlashCommandsSchema;
  [k: string]: unknown;
}
